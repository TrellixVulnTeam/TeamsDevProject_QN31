"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const path = tslib_1.__importStar(require("path"));
const configs_1 = require("../../plugins/resource/frontend/configs");
const tools_1 = require("../../common/tools");
const error_1 = require("../../plugins/resource/frontend/v3/error");
const clients_1 = require("../../plugins/resource/frontend/clients");
const deploy_1 = require("../../plugins/resource/frontend/ops/deploy");
const azureResource_1 = require("./azureResource");
const workflow_1 = require("../workflow");
let AzureStorageResource = class AzureStorageResource extends azureResource_1.AzureResource {
    constructor() {
        super(...arguments);
        this.name = "azure-storage";
        this.bicepModuleName = "azureStorage";
        this.outputs = {
            endpoint: {
                key: "endpoint",
                bicepVariable: "provisionOutputs.azureStorage{{componentName}}Output.value.endpoint",
            },
            resourceId: {
                key: "resourceId",
                bicepVariable: "provisionOutputs.azureStorage{{componentName}}Output.value.resourceId",
            },
            domain: {
                key: "domain",
                bicepVariable: "provisionOutputs.azureStorage{{componentName}}Output.value.domain",
            },
            indexPath: {
                key: "indexPath",
                bicepVariable: "provisionOutputs.azureStorage{{componentName}}Output.value.indexPath",
            },
        };
        this.finalOutputKeys = ["domain", "endpoint", "resourceId", "indexPath"];
    }
    configure(context, inputs) {
        const action = {
            name: "azure-storage.configure",
            type: "function",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: "configure azure storage (enable static web site)",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const parent = workflow_1.getHostingParentComponent(ctx.projectSetting, this.name);
                if (!parent) {
                    throw new Error("Hosting component no parent");
                }
                const frontendConfigRes = await buildFrontendConfig(ctx.envInfo, parent.name, ctx.tokenProvider.azureAccountProvider);
                if (frontendConfigRes.isErr()) {
                    return teamsfx_api_1.err(frontendConfigRes.error);
                }
                const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
                await client.enableStaticWebsite();
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: "configure azure storage (enable static web site)",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    deploy(context, inputs) {
        const action = {
            name: "azure-storage.deploy",
            type: "function",
            plan: (context, inputs) => {
                var _a;
                const parent = workflow_1.getHostingParentComponent(context.projectSetting, this.name);
                const deployDir = path.resolve(inputs.projectPath, (_a = parent === null || parent === void 0 ? void 0 : parent.folder) !== null && _a !== void 0 ? _a : "");
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: `deploy azure storage with path: ${deployDir}`,
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const parent = workflow_1.getHostingParentComponent(ctx.projectSetting, this.name);
                if (!(parent === null || parent === void 0 ? void 0 : parent.folder)) {
                    throw new Error("");
                }
                const deployDir = path.resolve(inputs.projectPath, parent.folder);
                const frontendConfigRes = await buildFrontendConfig(ctx.envInfo, parent.name, ctx.tokenProvider.azureAccountProvider);
                if (frontendConfigRes.isErr()) {
                    return teamsfx_api_1.err(frontendConfigRes.error);
                }
                const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
                const envName = ctx.envInfo.envName;
                await deploy_1.FrontendDeployment.doFrontendDeploymentV3(client, deployDir, envName);
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: `deploy azure storage with path: ${deployDir}`,
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
};
AzureStorageResource = tslib_1.__decorate([
    typedi_1.Service("azure-storage")
], AzureStorageResource);
exports.AzureStorageResource = AzureStorageResource;
async function buildFrontendConfig(envInfo, componentName, tokenProvider) {
    const credentials = await tokenProvider.getAccountCredentialAsync();
    if (!credentials) {
        return teamsfx_api_1.err(new error_1.UnauthenticatedError());
    }
    const storage = envInfo.state[componentName];
    const resourceId = storage === null || storage === void 0 ? void 0 : storage.resourceId;
    if (!resourceId) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError({
            source: "azure-storage",
            name: "StateValueMissingError",
            message: "Missing resourceIf for storage",
        }));
    }
    const frontendConfig = new configs_1.FrontendConfig(tools_1.getSubscriptionIdFromResourceId(resourceId), tools_1.getResourceGroupNameFromResourceId(resourceId), envInfo.state.solution.location, tools_1.getStorageAccountNameFromResourceId(resourceId), credentials);
    return teamsfx_api_1.ok(frontendConfig);
}
//# sourceMappingURL=azureStorage.js.map