"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateManifest = exports.buildTeamsAppPackage = exports.publishTeamsApp = exports.createOrUpdateTeamsAppByZip = exports.createOrUpdateTeamsApp = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const tools_1 = require("../../../common/tools");
const appStudio_1 = require("../../../plugins/resource/appstudio/appStudio");
const constants_1 = require("../../../plugins/resource/appstudio/constants");
const errors_1 = require("../../../plugins/resource/appstudio/errors");
const results_1 = require("../../../plugins/resource/appstudio/results");
const utils_1 = require("../../../plugins/resource/appstudio/utils/utils");
const constants_2 = require("../../constants");
const utils_2 = require("./utils");
/**
 * not support the scenario: user provide app package
 */
async function createOrUpdateTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    var _a, _b, _c;
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    if (inputs.appPackagePath) {
        return await createOrUpdateTeamsAppByZip(inputs.appPackagePath, ctx, tokenProvider);
    }
    const teamsAppId = (_a = envInfo.state[constants_2.ComponentNames.AppManifest]) === null || _a === void 0 ? void 0 : _a.teamsAppId;
    let create = true;
    if (teamsAppId) {
        try {
            await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            create = false;
        }
        catch (error) { }
    }
    if (create) {
        // create teams app
        try {
            const buildPackage = await buildTeamsAppPackage(inputs.projectPath, envInfo, true);
            if (buildPackage.isErr()) {
                return teamsfx_api_1.err(buildPackage.error);
            }
            const archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
            const appDefinition = await appStudio_1.AppStudioClient.createApp(archivedFile, appStudioTokenRes.value, ctx.logProvider);
            ctx.logProvider.info(`teams app created: ${appDefinition.teamsAppId}`);
            return teamsfx_api_1.ok(appDefinition.teamsAppId);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
        }
    }
    else {
        //update teams app
        const buildPackage = await buildTeamsAppPackage(inputs.projectPath, envInfo);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        const archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE)));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        const appDefinition = utils_1.convertToAppDefinition(manifest);
        const colorIconContent = (_b = zipEntries
            .find((x) => x.entryName === manifest.icons.color)) === null || _b === void 0 ? void 0 : _b.getData().toString("base64");
        const outlineIconContent = (_c = zipEntries
            .find((x) => x.entryName === manifest.icons.outline)) === null || _c === void 0 ? void 0 : _c.getData().toString("base64");
        try {
            const app = await appStudio_1.AppStudioClient.updateApp(manifest.id, appDefinition, appStudioTokenRes.value, undefined, colorIconContent, outlineIconContent);
            ctx.logProvider.info(`teams app updated: ${app.teamsAppId}`);
            return teamsfx_api_1.ok(app.teamsAppId);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppUpdateFailedError.name, errors_1.AppStudioError.TeamsAppUpdateFailedError.message(manifest.id)));
        }
    }
}
exports.createOrUpdateTeamsApp = createOrUpdateTeamsApp;
/**
 * not support the scenario: user provide app package
 */
async function createOrUpdateTeamsAppByZip(zipFilePath, ctx, tokenProvider) {
    var _a, _b;
    if (!(await fs_extra_1.default.pathExists(zipFilePath))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(zipFilePath)));
    }
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    const archivedFileBuffer = await fs_extra_1.default.readFile(zipFilePath);
    const zipEntries = new adm_zip_1.default(archivedFileBuffer).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
    if (!manifestFile) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE)));
    }
    const manifestString = manifestFile.getData().toString();
    const manifest = JSON.parse(manifestString);
    const teamsAppId = manifest.id;
    let create = true;
    if (teamsAppId) {
        try {
            await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            create = false;
        }
        catch (error) { }
    }
    if (create) {
        // create teams app
        try {
            const appDefinition = await appStudio_1.AppStudioClient.createApp(archivedFileBuffer, appStudioTokenRes.value, ctx.logProvider);
            return teamsfx_api_1.ok(appDefinition.teamsAppId);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
        }
    }
    else {
        //update teams app
        const appDefinition = utils_1.convertToAppDefinition(manifest);
        const colorIconContent = (_a = zipEntries
            .find((x) => x.entryName === manifest.icons.color)) === null || _a === void 0 ? void 0 : _a.getData().toString("base64");
        const outlineIconContent = (_b = zipEntries
            .find((x) => x.entryName === manifest.icons.outline)) === null || _b === void 0 ? void 0 : _b.getData().toString("base64");
        try {
            const app = await appStudio_1.AppStudioClient.updateApp(manifest.id, appDefinition, appStudioTokenRes.value, undefined, colorIconContent, outlineIconContent);
            return teamsfx_api_1.ok(app.teamsAppId);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppUpdateFailedError.name, errors_1.AppStudioError.TeamsAppUpdateFailedError.message(manifest.id)));
        }
    }
}
exports.createOrUpdateTeamsAppByZip = createOrUpdateTeamsAppByZip;
async function publishTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    var _a;
    let archivedFile;
    // User provided zip file
    if (inputs.appPackagePath) {
        if (await fs_extra_1.default.pathExists(inputs.appPackagePath)) {
            archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
    }
    else {
        const buildPackage = await buildTeamsAppPackage(inputs.projectPath, envInfo);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
    if (!manifestFile) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE)));
    }
    const manifestString = manifestFile.getData().toString();
    const manifest = JSON.parse(manifestString);
    // manifest.id === externalID
    const appStudioTokenRes = await tokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioTokenRes.value);
    if (existApp) {
        let executePublishUpdate = false;
        let description = `The app ${existApp.displayName} has already been submitted to tenant App Catalog.\nStatus: ${existApp.publishingState}\n`;
        if (existApp.lastModifiedDateTime) {
            description =
                description + `Last Modified: ${(_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString()}\n`;
        }
        description = description + "Do you want to submit a new update?";
        const res = await ctx.userInteraction.showMessage("warn", description, true, "Confirm");
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
            executePublishUpdate = true;
        if (executePublishUpdate) {
            const appId = await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioTokenRes.value);
            return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: true });
        }
        else {
            throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
        }
    }
    else {
        const appId = await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioTokenRes.value);
        return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: false });
    }
}
exports.publishTeamsApp = publishTeamsApp;
/**
 * Build appPackage.{envName}.zip
 * @returns Path for built Teams app package
 */
async function buildTeamsAppPackage(projectPath, envInfo, withEmptyCapabilities = false) {
    const buildFolderPath = path.join(projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName);
    await fs_extra_1.default.ensureDir(buildFolderPath);
    const appDefinitionRes = await getAppDefinitionAndManifest(projectPath, envInfo);
    if (appDefinitionRes.isErr()) {
        return teamsfx_api_1.err(appDefinitionRes.error);
    }
    const manifest = appDefinitionRes.value[1];
    if (!isUUID_1.default(manifest.id)) {
        manifest.id = uuid_1.v4();
    }
    if (withEmptyCapabilities) {
        manifest.bots = [];
        manifest.composeExtensions = [];
        manifest.configurableTabs = [];
        manifest.staticTabs = [];
        manifest.webApplicationInfo = undefined;
    }
    const appDirectory = await tools_1.getAppDirectory(projectPath);
    const colorFile = path.join(appDirectory, manifest.icons.color);
    if (!(await fs_extra_1.default.pathExists(colorFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile)));
    }
    const outlineFile = path.join(appDirectory, manifest.icons.outline);
    if (!(await fs_extra_1.default.pathExists(outlineFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile)));
    }
    const zip = new adm_zip_1.default();
    zip.addFile(constants_1.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
    // outline.png & color.png, relative path
    let dir = path.dirname(manifest.icons.color);
    zip.addLocalFile(colorFile, dir === "." ? "" : dir);
    dir = path.dirname(manifest.icons.outline);
    zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
    const zipFileName = path.join(buildFolderPath, `appPackage.${envInfo.envName}.zip`);
    zip.writeZip(zipFileName);
    const manifestFileName = path.join(buildFolderPath, `manifest.${envInfo.envName}.json`);
    if (await fs_extra_1.default.pathExists(manifestFileName)) {
        await fs_extra_1.default.chmod(manifestFileName, 0o777);
    }
    await fs_extra_1.default.writeFile(manifestFileName, JSON.stringify(manifest, null, 4));
    await fs_extra_1.default.chmod(manifestFileName, 0o444);
    return teamsfx_api_1.ok(zipFileName);
}
exports.buildTeamsAppPackage = buildTeamsAppPackage;
/**
 * Validate manifest
 * @returns an array of validation error strings
 */
async function validateManifest(manifest) {
    // TODO: import teamsfx-manifest package
    return teamsfx_api_1.ok([]);
}
exports.validateManifest = validateManifest;
async function getAppDefinitionAndManifest(projectPath, envInfo) {
    // Read template
    const manifestTemplateRes = await utils_2.readAppManifest(projectPath);
    if (manifestTemplateRes.isErr()) {
        return teamsfx_api_1.err(manifestTemplateRes.error);
    }
    let manifestString = JSON.stringify(manifestTemplateRes.value);
    // Render mustache template with state and config
    const view = {
        config: envInfo.config,
        state: envInfo.state,
    };
    manifestString = tools_1.compileHandlebarsTemplateString(manifestString, view);
    const manifest = JSON.parse(manifestString);
    const appDefinition = utils_1.convertToAppDefinition(manifest);
    return teamsfx_api_1.ok([appDefinition, manifest]);
}
//# sourceMappingURL=appStudio.js.map