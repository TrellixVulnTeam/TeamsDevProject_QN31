"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCapabilities = exports.AppManifest = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const featureFlags_1 = require("../../../common/featureFlags");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
const folder_1 = require("../../../folder");
const constants_1 = require("../../../plugins/resource/appstudio/constants");
const question_1 = require("../../../plugins/solution/fx-solution/question");
const constants_2 = require("../../constants");
const appStudio_1 = require("./appStudio");
const constants_3 = require("./constants");
const utils_1 = require("./utils");
let AppManifest = class AppManifest {
    constructor() {
        this.name = "app-manifest";
        this.outputs = {
            teamsAppId: {
                key: "teamsAppId",
            },
            tenantId: {
                key: "tenantId",
            },
        };
        this.finalOutputKeys = ["teamsAppId", "tenantId"];
    }
    init(context, inputs) {
        const createFilePath = [
            path.join(inputs.projectPath, "templates", "appPackage", "resources", "color.png"),
            path.join(inputs.projectPath, "templates", "appPackage", "resources", "outline.png"),
            path.join(inputs.projectPath, "templates", "appPackage", "manifest.template.json"),
        ];
        const effect = {
            type: "file",
            operate: "create",
            filePath: createFilePath,
        };
        const action = {
            name: "app-manifest.init",
            type: "function",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([effect]);
            },
            execute: async (context, inputs) => {
                const existingApp = inputs.existingApp;
                const manifestString = constants_3.TEAMS_APP_MANIFEST_TEMPLATE;
                const manifest = JSON.parse(manifestString);
                if (existingApp || !projectSettingsHelperV3_1.hasTab(context.projectSetting)) {
                    manifest.developer = constants_1.DEFAULT_DEVELOPER;
                }
                const templateFolder = path.join(inputs.projectPath, "templates");
                await fs_extra_1.default.ensureDir(templateFolder);
                const appPackageFolder = path.join(templateFolder, "appPackage");
                await fs_extra_1.default.ensureDir(appPackageFolder);
                const resourcesFolder = path.resolve(appPackageFolder, "resources");
                await fs_extra_1.default.ensureDir(resourcesFolder);
                const targetManifestPath = path.join(appPackageFolder, "manifest.template.json");
                await fs_extra_1.default.writeFile(targetManifestPath, JSON.stringify(manifest, null, 4));
                const templatesFolder = folder_1.getTemplatesFolder();
                const defaultColorPath = path.join(templatesFolder, constants_1.COLOR_TEMPLATE);
                const defaultOutlinePath = path.join(templatesFolder, constants_1.OUTLINE_TEMPLATE);
                await fs_extra_1.default.copy(defaultColorPath, path.join(resourcesFolder, constants_1.DEFAULT_COLOR_PNG_FILENAME));
                await fs_extra_1.default.copy(defaultOutlinePath, path.join(resourcesFolder, constants_1.DEFAULT_OUTLINE_PNG_FILENAME));
                return teamsfx_api_1.ok([effect]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    addCapability(context, inputs) {
        const effect = {
            type: "file",
            operate: "replace",
            filePath: path.join(inputs.projectPath, "templates", "appPackage", "manifest.template.json"),
        };
        const action = {
            name: "app-manifest.addCapability",
            type: "function",
            plan: (context, inputs) => {
                effect.remarks = `add capabilities (${JSON.stringify(inputs.capabilities)}) in manifest`;
                return teamsfx_api_1.ok([effect]);
            },
            execute: async (context, inputs) => {
                const capabilities = inputs.capabilities;
                const res = await addCapabilities(inputs, capabilities);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                effect.remarks = `capabilities: ${capabilities.map((c) => c.name).join(",")}`;
                return teamsfx_api_1.ok([effect]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    provision(context, inputs) {
        const action = {
            name: "app-manifest.provision",
            type: "function",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "create or update teams app",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const res = await appStudio_1.createOrUpdateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                ctx.envInfo.state[constants_2.ComponentNames.AppManifest].teamsAppId = res.value;
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "create or update teams app",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    configure(context, inputs) {
        const action = {
            name: "app-manifest.configure",
            type: "function",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "update teams app",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const res = await appStudio_1.createOrUpdateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "update teams app",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    publish(context, inputs) {
        const action = {
            name: "app-manifest.publish",
            type: "function",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "publish teams app",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const res = await appStudio_1.publishTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider.m365TokenProvider);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "teams.microsoft.com",
                        remarks: "publish teams app",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
};
AppManifest = tslib_1.__decorate([
    typedi_1.Service("app-manifest")
], AppManifest);
exports.AppManifest = AppManifest;
async function addCapabilities(inputs, capabilities) {
    var _a, _b;
    const appManifestRes = await utils_1.readAppManifest(inputs.projectPath);
    if (appManifestRes.isErr())
        return teamsfx_api_1.err(appManifestRes.error);
    const appManifest = appManifestRes.value;
    for (const capability of capabilities) {
        let staticTabIndex = (_b = (_a = appManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        switch (capability.name) {
            case "staticTab":
                appManifest.staticTabs = appManifest.staticTabs || [];
                if (capability.snippet) {
                    appManifest.staticTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        const template = lodash_1.cloneDeep(constants_1.STATIC_TABS_TPL_EXISTING_APP[0]);
                        template.entityId = "index" + staticTabIndex;
                        appManifest.staticTabs.push(template);
                    }
                    else {
                        const template = lodash_1.cloneDeep(constants_3.STATIC_TABS_TPL_V3[0]);
                        template.entityId = "index" + staticTabIndex;
                        appManifest.staticTabs.push(template);
                    }
                    staticTabIndex++;
                }
                break;
            case "configurableTab":
                appManifest.configurableTabs = appManifest.configurableTabs || [];
                if (capability.snippet) {
                    appManifest.configurableTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.configurableTabs = appManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_EXISTING_APP);
                    }
                    else {
                        appManifest.configurableTabs =
                            appManifest.configurableTabs.concat(constants_3.CONFIGURABLE_TABS_TPL_V3);
                    }
                }
                break;
            case "Bot":
                appManifest.bots = appManifest.bots || [];
                if (capability.snippet) {
                    appManifest.bots.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_EXISTING_APP);
                    }
                    else {
                        if (appManifest.bots === undefined) {
                            appManifest.bots = [];
                        }
                        if (featureFlags_1.isBotNotificationEnabled()) {
                            const scenariosRaw = inputs[question_1.AzureSolutionQuestionNames.Scenarios];
                            const scenarios = Array.isArray(scenariosRaw) ? scenariosRaw : [];
                            if (scenarios.includes(question_1.BotScenario.CommandAndResponseBot)) {
                                // command and response bot
                                appManifest.bots = appManifest.bots.concat(constants_3.BOTS_TPL_FOR_COMMAND_AND_RESPONSE_V3);
                            }
                            else if (scenarios.includes(question_1.BotScenario.NotificationBot)) {
                                // notification
                                appManifest.bots = appManifest.bots.concat(constants_3.BOTS_TPL_FOR_NOTIFICATION_V3);
                            }
                            else {
                                // legacy bot
                                appManifest.bots = appManifest.bots.concat(constants_3.BOTS_TPL_V3);
                            }
                        }
                        else {
                            appManifest.bots = appManifest.bots.concat(constants_3.BOTS_TPL_V3);
                        }
                    }
                }
                break;
            case "MessageExtension":
                appManifest.composeExtensions = appManifest.composeExtensions || [];
                if (capability.snippet) {
                    appManifest.composeExtensions.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.composeExtensions = appManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                    }
                    else {
                        appManifest.composeExtensions =
                            appManifest.composeExtensions.concat(constants_3.COMPOSE_EXTENSIONS_TPL_V3);
                    }
                }
                break;
            case "WebApplicationInfo":
                if (capability.snippet) {
                    appManifest.webApplicationInfo = capability.snippet;
                }
                else {
                    appManifest.webApplicationInfo = constants_3.WEB_APPLICATION_INFO_V3;
                }
                break;
        }
    }
    await utils_1.writeAppManifest(appManifest, inputs.projectPath);
    return teamsfx_api_1.ok(undefined);
}
exports.addCapabilities = addCapabilities;
//# sourceMappingURL=appManifest.js.map