"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilFunctions = exports.ConfigureActionImplement = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
const constants_1 = require("../../../constants");
const logger_1 = require("../../../middleware/logger");
const progressbar_1 = require("../../../middleware/progressbar");
const runWithCatchError_1 = require("../../../middleware/runWithCatchError");
const telemetry_1 = require("../../../middleware/telemetry");
const management_1 = require("../clients/management");
const sql_1 = require("../clients/sql");
const config_1 = require("../config");
const constants_2 = require("../constants");
const errors_1 = require("../errors");
const questions_1 = require("../questions");
const results_1 = require("../results");
const common_1 = require("../utils/common");
class ConfigureActionImplement {
    static async execute(context, inputs) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const ctx = context;
        const actionContext = context;
        const solutionConfig = ctx.envInfo.state.solution;
        const state = ctx.envInfo.state[constants_1.ComponentStateKeys[constants_1.ComponentNames.AzureSQL]];
        const sqlMgrConfig = config_1.LoadManagementConfig(state);
        const sqlMgrClient = await management_1.ManagementClient.create(ctx.tokenProvider.azureAccountProvider, sqlMgrConfig);
        (_a = actionContext.logger) === null || _a === void 0 ? void 0 : _a.info(constants_2.Message.addFirewall);
        await sqlMgrClient.addLocalFirewallRule();
        const adminInfo = await UtilFunctions.parseLoginToken(ctx.tokenProvider.azureAccountProvider);
        (_b = actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(ConfigureActionImplement.progressMessage.addAadmin);
        const existAdmin = await UtilFunctions.CheckAndSetAadAdmin(sqlMgrClient, adminInfo.name, adminInfo.objectId, solutionConfig.tenantId);
        if (existAdmin) {
            (_c = actionContext.logger) === null || _c === void 0 ? void 0 : _c.info(constants_2.Message.skipAddAadAdmin);
        }
        else {
            (_d = actionContext.logger) === null || _d === void 0 ? void 0 : _d.info(constants_2.Message.addSqlAadAdmin);
        }
        // update outputKeys
        const databases = config_1.loadDatabases(state);
        const resource = typedi_1.default.get(constants_1.ComponentNames.AzureSQL);
        resource.finalOutputKeys.push(...Object.keys(databases));
        const identity = UtilFunctions.getIdentity(ctx);
        const sqlConfig = config_1.LoadSqlConfig(state, identity);
        const skipAddingUser = await UtilFunctions.getSkipAddingUser(solutionConfig, ctx.tokenProvider.azureAccountProvider);
        (_e = actionContext.telemetry) === null || _e === void 0 ? void 0 : _e.addProperty(constants_2.Telemetry.properties.skipAddingUser, skipAddingUser ? constants_1.TelemetryConstants.values.yes : constants_1.TelemetryConstants.values.no);
        (_f = actionContext.telemetry) === null || _f === void 0 ? void 0 : _f.addProperty(constants_2.Telemetry.properties.dbCount, sqlConfig.databases.length.toString());
        if (!skipAddingUser) {
            if (adminInfo.userType === common_1.UserType.User) {
                (_g = actionContext.progressBar) === null || _g === void 0 ? void 0 : _g.next(ConfigureActionImplement.progressMessage.addUser);
                const sqlClient = await sql_1.SqlClient.create(ctx.tokenProvider.azureAccountProvider, sqlConfig);
                (_h = actionContext.logger) === null || _h === void 0 ? void 0 : _h.info(constants_2.Message.addDatabaseUser(identity));
                await UtilFunctions.addDatabaseUser(ctx.logProvider, sqlClient, sqlMgrClient);
            }
            else {
                const message = errors_1.ErrorMessage.ServicePrincipalWarning(identity, sqlConfig.databases.join(","));
                (_j = actionContext.logger) === null || _j === void 0 ? void 0 : _j.warning(`${message}. You can follow ${constants_2.HelpLinks.default} to add database user ${identity}`);
            }
        }
        else {
            (_k = actionContext.logger) === null || _k === void 0 ? void 0 : _k.warning(`Skip adding database user. You can follow ${constants_2.HelpLinks.default} to add database user ${identity}`);
        }
        await sqlMgrClient.deleteLocalFirewallRule();
        return teamsfx_api_1.ok([{ type: "service", name: "azure", remarks: "configure azure-sql" }]);
    }
    static get() {
        return {
            name: `${constants_1.ComponentNames.AzureSQL}.${constants_1.ActionNames.configure}`,
            type: constants_1.ActionTypeFunction,
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([{ type: "service", name: "azure", remarks: "configure azure-sql" }]);
            },
            execute: ConfigureActionImplement.execute,
        };
    }
}
ConfigureActionImplement.source = "SQL";
ConfigureActionImplement.stage = "post-provision";
ConfigureActionImplement.telemetryComponentName = "fx-resource-azure-sql";
ConfigureActionImplement.progressTitle = "Configuring SQL";
ConfigureActionImplement.progressMessage = {
    addAadmin: "Configure aad admin for SQL",
    addUser: "Configure database user",
};
ConfigureActionImplement.loggerPrefix = "[SQL Component]";
ConfigureActionImplement.logFormatter = (message) => `${ConfigureActionImplement.loggerPrefix} ${message}`;
tslib_1.__decorate([
    lib_1.hooks([
        telemetry_1.TelemetryMW(telemetry_1.ActionTelemetryImplement.bind(null, ConfigureActionImplement.stage, ConfigureActionImplement.telemetryComponentName)),
        runWithCatchError_1.RunWithCatchErrorMW(ConfigureActionImplement.source, runWithCatchError_1.ActionErrorHandler),
        progressbar_1.ProgressBarMW(ConfigureActionImplement.progressTitle, Object.keys(ConfigureActionImplement.progressMessage).length),
        logger_1.LoggerMW(logger_1.ActionLogger.bind(null, ConfigureActionImplement.logFormatter)),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ConfigureActionImplement, "execute", null);
exports.ConfigureActionImplement = ConfigureActionImplement;
class UtilFunctions {
    static async CheckAndSetAadAdmin(client, aadAdmin, objectId, tenantId) {
        const existAdmin = await client.existAadAdmin(aadAdmin);
        if (!existAdmin) {
            await client.addAADadmin(tenantId, objectId, aadAdmin);
        }
        return existAdmin;
    }
    static async parseLoginToken(azureAccountProvider) {
        // get login user info to set aad admin in sql
        try {
            const credential = await azureAccountProvider.getAccountCredentialAsync();
            const token = await credential.getToken();
            const accessToken = token.accessToken;
            return common_1.parseToken(accessToken);
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlUserInfoError.name, errors_1.ErrorMessage.SqlUserInfoError.message(), error);
        }
    }
    static async getSkipAddingUser(config, azureAccountProvider) {
        const skipAddingUser = config[constants_2.Constants.skipAddingSqlUser];
        if (skipAddingUser === undefined) {
            return (await (azureAccountProvider === null || azureAccountProvider === void 0 ? void 0 : azureAccountProvider.getIdentityCredentialAsync())) ? false : true;
        }
        else {
            return skipAddingUser;
        }
    }
    static getIdentity(ctx) {
        const config = ctx.envInfo.state[constants_1.ComponentStateKeys[constants_1.ComponentNames.Identity]];
        const identity = config[constants_2.Constants.identityName];
        if (!identity) {
            const error = results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlGetConfigError.name, errors_1.ErrorMessage.SqlGetConfigError.message(constants_2.Constants.identityPlugin, constants_2.Constants.identityName));
            throw error;
        }
        return identity;
    }
    static async addDatabaseUser(logProvider, sqlClient, managementClient) {
        let retryCount = 0;
        const databaseWithUser = {};
        sqlClient.config.databases.forEach((element) => {
            databaseWithUser[element] = false;
        });
        while (true) {
            try {
                for (const database in databaseWithUser) {
                    if (!databaseWithUser[database]) {
                        await sqlClient.addDatabaseUser(database);
                        databaseWithUser[database] = true;
                    }
                }
                return;
            }
            catch (error) {
                if (!sql_1.SqlClient.isFireWallError(error === null || error === void 0 ? void 0 : error.innerError) ||
                    retryCount >= constants_2.Constants.maxRetryTimes) {
                    throw error;
                }
                else {
                    retryCount++;
                    logProvider.warning(`[${constants_2.Constants.pluginName}] Retry adding new firewall rule to access azure sql, because the local IP address has changed after added firewall rule for it. [Retry time: ${retryCount}]`);
                    await managementClient.addLocalFirewallRule();
                }
            }
        }
    }
    static buildQuestionNode() {
        const sqlNode = new teamsfx_api_1.QTreeNode({
            type: "group",
        });
        sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.adminNameQuestion));
        sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.adminPasswordQuestion));
        sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.confirmPasswordQuestion));
        return sqlNode;
    }
}
exports.UtilFunctions = UtilFunctions;
//# sourceMappingURL=configure.js.map