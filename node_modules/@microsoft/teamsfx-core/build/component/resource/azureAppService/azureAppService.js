"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureAppService = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const utils_1 = require("../../../common/azure-hosting/utils");
const utils = tslib_1.__importStar(require("../../../plugins/resource/bot/utils/common"));
const mapping_1 = require("../../../plugins/resource/bot/v2/mapping");
const errors_1 = require("./errors");
const azureResource_1 = require("./../azureResource");
const messages_1 = require("./messages");
const workflow_1 = require("../../workflow");
class AzureAppService extends azureResource_1.AzureResource {
    generateBicep(context, inputs) {
        this.getTemplateContext = (context, inputs) => {
            const configs = [];
            configs.push(mapping_1.getRuntime(mapping_1.getLanguage(context.projectSetting.programmingLanguage)));
            this.templateContext.configs = configs;
            return this.templateContext;
        };
        return super.generateBicep(context, inputs);
    }
    deploy(context, inputs) {
        const action = {
            name: `${this.name}.deploy`,
            type: "function",
            plan: (context, inputs) => {
                var _a;
                const parent = workflow_1.getHostingParentComponent(context.projectSetting, this.name);
                const deployDir = path.resolve(inputs.projectPath, (_a = parent === null || parent === void 0 ? void 0 : parent.folder) !== null && _a !== void 0 ? _a : "");
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: `deploy ${this.displayName} in folder: ${deployDir}`,
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const parent = workflow_1.getHostingParentComponent(ctx.projectSetting, this.name);
                // Preconditions checking.
                if (!inputs.projectPath || !(parent === null || parent === void 0 ? void 0 : parent.artifactFolder)) {
                    throw new errors_1.PreconditionError(this.alias, messages_1.Messages.WorkingDirIsMissing, []);
                }
                const publishDir = path.resolve(inputs.projectPath, parent.artifactFolder);
                const packDirExisted = await fs_extra_1.default.pathExists(publishDir);
                if (!packDirExisted) {
                    throw new errors_1.PackDirectoryExistenceError(this.alias);
                }
                const state = ctx.envInfo.state[parent.name];
                const resourceId = errors_1.CheckThrowSomethingMissing(this.alias, this.outputs.resourceId.key, state[this.outputs.resourceId.key]);
                const zipBuffer = await utils.zipFolderAsync(publishDir, "");
                await utils_1.azureWebSiteDeploy(resourceId, ctx.tokenProvider, zipBuffer);
                return teamsfx_api_1.ok([
                    {
                        type: "service",
                        name: "azure",
                        remarks: `deploy ${this.displayName} in folder: ${publishDir}`,
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
}
exports.AzureAppService = AzureAppService;
//# sourceMappingURL=azureAppService.js.map