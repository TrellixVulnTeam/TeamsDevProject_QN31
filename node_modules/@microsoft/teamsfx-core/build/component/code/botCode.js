"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var BotCodeProvider_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLangKey = exports.BotCodeProvider = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../common/template-utils/templatesActions");
const constants_1 = require("../../plugins/resource/bot/constants");
const programmingLanguage_1 = require("../../plugins/resource/bot/enums/programmingLanguage");
const strings_1 = require("../../plugins/resource/bot/resources/strings");
const error_1 = require("../../plugins/resource/bot/v3/error");
const constants_2 = require("../constants");
const workflow_1 = require("../workflow");
const utils = tslib_1.__importStar(require("../../plugins/resource/bot/utils/common"));
const fs = tslib_1.__importStar(require("fs-extra"));
const errors_1 = require("../../plugins/resource/bot/errors");
const question_1 = require("../../core/question");
const utils_1 = require("../../common/utils");
/**
 * bot scaffold plugin
 */
let BotCodeProvider = BotCodeProvider_1 = class BotCodeProvider {
    constructor() {
        this.name = "bot-code";
    }
    generate(context, inputs) {
        const action = {
            name: "bot-code.generate",
            type: "function",
            plan: (context, inputs) => {
                const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
                if (!teamsBot)
                    return teamsfx_api_1.ok([]);
                const folder = inputs.folder || strings_1.CommonStrings.BOT_WORKING_DIR_NAME;
                return teamsfx_api_1.ok([
                    "add component 'bot-code' in projectSettings",
                    `scaffold bot source code in folder: ${path.join(inputs.projectPath, folder)}`,
                ]);
            },
            execute: async (context, inputs) => {
                var _a;
                const projectSettings = context.projectSetting;
                const appName = projectSettings.appName;
                const language = (inputs === null || inputs === void 0 ? void 0 : inputs["programming-language"]) ||
                    context.projectSetting.programmingLanguage ||
                    "javascript";
                const botFolder = inputs.folder || language === "csharp" ? "" : strings_1.CommonStrings.BOT_WORKING_DIR_NAME;
                const teamsBot = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.TeamsBot);
                if (!teamsBot)
                    return teamsfx_api_1.ok([]);
                lodash_1.merge(teamsBot, { build: true, folder: botFolder });
                const group_name = constants_1.TemplateProjectsConstants.GROUP_NAME_BOT;
                const lang = convertToLangKey(language);
                const workingDir = path.join(inputs.projectPath, botFolder);
                const safeProjectName = (_a = inputs[question_1.CoreQuestionNames.SafeProjectName]) !== null && _a !== void 0 ? _a : utils_1.convertToAlphanumericOnly(appName);
                for (const scenario of inputs.scenarios) {
                    await templatesActions_1.scaffoldFromTemplates({
                        group: group_name,
                        lang: lang,
                        scenario: scenario,
                        dst: workingDir,
                        fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn({
                            ProjectName: appName,
                            SafeProjectName: safeProjectName,
                        }),
                        fileNameReplaceFn: (name, data) => name.replace(/ProjectName/, appName).replace(/\.tpl/, ""),
                        onActionError: async (action, context, error) => {
                            switch (action.name) {
                                case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                                case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                                    break;
                                case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                                    throw new error_1.TemplateZipFallbackError();
                                case templatesActions_1.ScaffoldActionName.Unzip:
                                    throw new error_1.UnzipError(context.dst);
                                default:
                                    throw new Error(error.message);
                            }
                        },
                    });
                }
                return teamsfx_api_1.ok([
                    `scaffold bot source code in folder: ${path.join(inputs.projectPath, botFolder)}`,
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    build(context, inputs) {
        const action = {
            name: "bot-code.build",
            type: "function",
            plan: (context, inputs) => {
                const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
                if (!teamsBot)
                    return teamsfx_api_1.ok([]);
                const packDir = teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.folder;
                if (!packDir)
                    return teamsfx_api_1.ok([]);
                return teamsfx_api_1.ok([`build project: ${packDir}`]);
            },
            execute: async (context, inputs) => {
                const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
                if (!teamsBot)
                    return teamsfx_api_1.ok([]);
                const packDir = path.join(inputs.projectPath, teamsBot.folder);
                const language = context.projectSetting.programmingLanguage || "javascript";
                if (language === programmingLanguage_1.ProgrammingLanguage.TypeScript) {
                    //Typescript needs tsc build before deploy because of windows app server. other languages don"t need it.
                    try {
                        await utils.execute("npm install", packDir);
                        await utils.execute("npm run build", packDir);
                        lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
                    }
                    catch (e) {
                        throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}, ${strings_1.Commands.NPM_BUILD}`, packDir, e);
                    }
                }
                else if (language === programmingLanguage_1.ProgrammingLanguage.JavaScript) {
                    try {
                        // fail to npm install @microsoft/teamsfx on azure web app, so pack it locally.
                        await utils.execute("npm install", packDir);
                        lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
                    }
                    catch (e) {
                        throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}`, packDir, e);
                    }
                }
                else if (language === programmingLanguage_1.ProgrammingLanguage.Csharp) {
                    const projectFileName = `${context.projectSetting.appName}.csproj`;
                    const framework = await BotCodeProvider_1.getFrameworkVersion(path.join(packDir, projectFileName));
                    await utils.execute(`dotnet publish --configuration Release`, packDir);
                    const artifactFolder = path.join(".", "bin", "Release", framework, "publish");
                    lodash_1.merge(teamsBot, { build: true, artifactFolder: artifactFolder });
                }
                return teamsfx_api_1.ok([`build project: ${packDir}`]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    /**
     * read dotnet framework version from project file
     * @param projectFilePath project base folder
     */
    static async getFrameworkVersion(projectFilePath) {
        try {
            const reg = /(?<=<TargetFramework>)(.*)(?=<)/gim;
            const content = await fs.readFile(projectFilePath, "utf8");
            const framework = content.match(reg);
            if (framework === null || framework === void 0 ? void 0 : framework.length) {
                return framework[0].trim();
            }
        }
        catch (_a) { }
        return constants_1.DEFAULT_DOTNET_FRAMEWORK;
    }
};
BotCodeProvider = BotCodeProvider_1 = tslib_1.__decorate([
    typedi_1.Service("bot-code")
], BotCodeProvider);
exports.BotCodeProvider = BotCodeProvider;
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case "javascript": {
            return "js";
        }
        case "typescript": {
            return "ts";
        }
        case "csharp": {
            return "csharp";
        }
        default: {
            return "js";
        }
    }
}
exports.convertToLangKey = convertToLangKey;
//# sourceMappingURL=botCode.js.map