"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabCodeProvider = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../common/template-utils/templatesActions");
const utils_1 = require("../../common/utils");
const question_1 = require("../../core/question");
const error_1 = require("../../plugins/resource/bot/v3/error");
const constants_1 = require("../../plugins/resource/frontend/constants");
const deploy_1 = require("../../plugins/resource/frontend/ops/deploy");
const errors_1 = require("../../plugins/resource/frontend/resources/errors");
const messages_1 = require("../../plugins/resource/frontend/resources/messages");
const templateInfo_1 = require("../../plugins/resource/frontend/resources/templateInfo");
const constants_2 = require("../constants");
const workflow_1 = require("../workflow");
const botCode_1 = require("./botCode");
const env_1 = require("../../plugins/resource/frontend/env");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const constants_3 = require("../../plugins/resource/frontend/dotnet/constants");
const utils_2 = require("../../plugins/resource/frontend/utils");
const errors_2 = require("../../plugins/resource/bot/errors");
/**
 * tab scaffold
 */
let TabCodeProvider = class TabCodeProvider {
    constructor() {
        this.name = "tab-code";
    }
    generate(context, inputs) {
        const action = {
            name: "tab-code.generate",
            type: "function",
            plan: (context, inputs) => {
                const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
                if (!teamsTab)
                    return teamsfx_api_1.ok([]);
                const language = (inputs === null || inputs === void 0 ? void 0 : inputs["programming-language"]) ||
                    context.projectSetting.programmingLanguage ||
                    "javascript";
                const folder = inputs.folder || language === "csharp" ? "" : constants_1.FrontendPathInfo.WorkingDir;
                return teamsfx_api_1.ok([`scaffold tab source code in folder: ${path.join(inputs.projectPath, folder)}`]);
            },
            execute: async (ctx, inputs) => {
                var _a;
                const projectSettings = ctx.projectSetting;
                const appName = projectSettings.appName;
                const language = (inputs === null || inputs === void 0 ? void 0 : inputs["programming-language"]) ||
                    context.projectSetting.programmingLanguage ||
                    "javascript";
                const folder = inputs.folder || language === "csharp" ? "" : constants_1.FrontendPathInfo.WorkingDir;
                const teamsTab = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.TeamsTab);
                if (!teamsTab)
                    return teamsfx_api_1.ok([]);
                lodash_1.merge(teamsTab, { build: true, provision: language != "csharp", folder: folder });
                const langKey = botCode_1.convertToLangKey(language);
                const workingDir = path.join(inputs.projectPath, folder);
                const hasFunction = false; //TODO
                const safeProjectName = (_a = inputs[question_1.CoreQuestionNames.SafeProjectName]) !== null && _a !== void 0 ? _a : utils_1.convertToAlphanumericOnly(appName);
                const variables = {
                    showFunction: hasFunction.toString(),
                    ProjectName: appName,
                    SafeProjectName: safeProjectName,
                };
                await templatesActions_1.scaffoldFromTemplates({
                    group: templateInfo_1.TemplateInfo.TemplateGroupName,
                    lang: langKey,
                    scenario: templateInfo_1.Scenario.Default,
                    dst: workingDir,
                    fileNameReplaceFn: (name, data) => name.replace(/ProjectName/, appName).replace(/\.tpl/, ""),
                    fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
                    onActionEnd: async (action, context) => {
                        var _a;
                        if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                            ctx.logProvider.info(messages_1.Messages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : constants_1.Constants.EmptyString));
                        }
                    },
                    onActionError: async (action, context, error) => {
                        ctx.logProvider.info(error.toString());
                        switch (action.name) {
                            case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                            case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                                ctx.logProvider.info(messages_1.Messages.FailedFetchTemplate);
                                break;
                            case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                                throw new error_1.TemplateZipFallbackError();
                            case templatesActions_1.ScaffoldActionName.Unzip:
                                throw new errors_1.UnzipTemplateError();
                            default:
                                throw new errors_1.UnknownScaffoldError();
                        }
                    },
                });
                return teamsfx_api_1.ok([`scaffold tab source code in folder: ${workingDir}`]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    configure(context, inputs) {
        const action = {
            name: "tab-code.configure",
            type: "function",
            plan: (context, inputs) => {
                const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
                if (!teamsTab)
                    return teamsfx_api_1.ok([]);
                const tabDir = teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.folder;
                if (!tabDir || !inputs.env)
                    return teamsfx_api_1.ok([]);
                return teamsfx_api_1.ok([
                    {
                        type: "file",
                        filePath: env_1.envFilePath(inputs.env, path.join(inputs.projectPath, tabDir)),
                        operate: "create",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
                const tabDir = teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.folder;
                if (!tabDir || !inputs.env)
                    return teamsfx_api_1.ok([]);
                const envFile = env_1.envFilePath(inputs.env, path.join(inputs.projectPath, tabDir));
                const envs = this.collectEnvs(context);
                await env_1.saveEnvFile(envFile, { teamsfxRemoteEnvs: envs, customizedRemoteEnvs: {} });
                return teamsfx_api_1.ok([
                    {
                        type: "file",
                        filePath: envFile,
                        operate: "create",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    build(context, inputs) {
        const action = {
            name: "tab-code.build",
            type: "function",
            plan: (context, inputs) => {
                const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
                if (!teamsTab)
                    return teamsfx_api_1.ok([]);
                const tabDir = teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.folder;
                if (!tabDir)
                    return teamsfx_api_1.ok([]);
                return teamsfx_api_1.ok([`build project: ${tabDir}`]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
                if (!teamsTab)
                    return teamsfx_api_1.ok([]);
                if (teamsTab.folder == undefined)
                    throw new Error("path not found");
                const tabPath = path.resolve(inputs.projectPath, teamsTab.folder);
                const artifactFolder = projectSettingsHelper_1.isVSProject(context.projectSetting)
                    ? await this.doBlazorBuild(tabPath)
                    : await this.doReactBuild(tabPath, ctx.envInfo.envName);
                lodash_1.merge(teamsTab, {
                    build: true,
                    artifactFolder: path.join(teamsTab.folder, artifactFolder),
                });
                return teamsfx_api_1.ok([`build project: ${tabPath}`]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    collectEnvs(ctx) {
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        // TODO: add environemnt variables for aad, simple auth and function api
        addToEnvs(env_1.EnvKeys.StartLoginPage, constants_1.DependentPluginInfo.StartLoginPageURL);
        return envs;
    }
    async doBlazorBuild(tabPath) {
        const command = constants_3.DotnetCommands.buildRelease("win-x86");
        try {
            await utils_2.Utils.execute(command, tabPath);
        }
        catch (e) {
            throw new errors_2.CommandExecutionError(command, tabPath, e);
        }
        return path.join("bin", "Release", "net6.0", "win-x86", "publish");
    }
    async doReactBuild(tabPath, envName) {
        await deploy_1.FrontendDeployment.doFrontendBuildV3(tabPath, envName);
        return "build";
    }
};
TabCodeProvider = tslib_1.__decorate([
    typedi_1.Service("tab-code")
], TabCodeProvider);
exports.TabCodeProvider = TabCodeProvider;
//# sourceMappingURL=tabCode.js.map