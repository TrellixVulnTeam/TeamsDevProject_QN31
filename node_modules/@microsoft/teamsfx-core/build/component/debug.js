"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateLocalDebugSettings = exports.configLocalEnvironment = exports.setupLocalEnvironment = exports.DebugComponent = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const constants_1 = require("../common/local/constants");
const localCertificateManager_1 = require("../common/local/localCertificateManager");
const localEnvProvider_1 = require("../common/local/localEnvProvider");
const projectSettingsHelper_1 = require("../common/local/projectSettingsHelper");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const tools_1 = require("../common/tools");
const error_1 = require("../plugins/solution/fx-solution/debug/error");
const codespace_1 = require("../plugins/solution/fx-solution/debug/util/codespace");
const localService_1 = require("../plugins/solution/fx-solution/debug/util/localService");
const ngrok_1 = require("../plugins/solution/fx-solution/debug/util/ngrok");
const telemetry_1 = require("../plugins/solution/fx-solution/debug/util/telemetry");
const constants_2 = require("./constants");
const Launch = tslib_1.__importStar(require("../plugins/solution/fx-solution/debug/util/launch"));
const LaunchNext = tslib_1.__importStar(require("../plugins/solution/fx-solution/debug/util/launchNext"));
const Tasks = tslib_1.__importStar(require("../plugins/solution/fx-solution/debug/util/tasks"));
const TasksNext = tslib_1.__importStar(require("../plugins/solution/fx-solution/debug/util/tasksNext"));
const Settings = tslib_1.__importStar(require("../plugins/solution/fx-solution/debug/util/settings"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const scaffolding_1 = require("../plugins/solution/fx-solution/debug/scaffolding");
const utils_1 = require("./utils");
let DebugComponent = class DebugComponent {
    constructor() {
        this.name = "debug";
    }
    setupLocalEnvInfo(context, inputs) {
        const action = {
            name: "debug.setupLocalEnvInfo",
            type: "function",
            execute: async (context, inputs) => {
                const ctx = context;
                const localEnvSetupResult = await setupLocalEnvironment(ctx, inputs, ctx.envInfo);
                if (localEnvSetupResult.isErr()) {
                    return teamsfx_api_1.err(localEnvSetupResult.error);
                }
                return teamsfx_api_1.ok([]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    configLocalEnvInfo(context, inputs) {
        const action = {
            type: "function",
            name: "debug.configLocalEnvInfo",
            plan: (context, inputs) => {
                return teamsfx_api_1.ok([]);
            },
            execute: async (context, inputs) => {
                const ctx = context;
                const localConfigResult = await configLocalEnvironment(ctx, inputs, ctx.envInfo);
                if (localConfigResult.isErr()) {
                    return teamsfx_api_1.err(localConfigResult.error);
                }
                return teamsfx_api_1.ok([]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
    generateLocalDebugSettings(context, inputs) {
        const action = {
            type: "function",
            name: "debug.generateLocalDebugSettings",
            plan: (context, inputs) => {
                const files = [
                    `${inputs.projectPath}/.vscode/launch.json`,
                    `${inputs.projectPath}/.vscode/tasks.json`,
                ];
                return teamsfx_api_1.ok(utils_1.createFilesEffects(files, "replace"));
            },
            execute: async (context, inputs) => {
                const res = await generateLocalDebugSettings(context, inputs);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
                const files = [
                    `${inputs.projectPath}/.vscode/launch.json`,
                    `${inputs.projectPath}/.vscode/tasks.json`,
                ];
                return teamsfx_api_1.ok(utils_1.createFilesEffects(files, "replace"));
            },
        };
        return teamsfx_api_1.ok(action);
    }
};
DebugComponent = tslib_1.__decorate([
    typedi_1.Service("debug")
], DebugComponent);
exports.DebugComponent = DebugComponent;
async function setupLocalEnvironment(ctx, inputs, envInfo) {
    var _a, _b, _c, _d;
    var _e, _f, _g, _h;
    const vscEnv = inputs.vscodeEnv;
    const includeTab = projectSettingsHelperV3_1.hasAzureTab(ctx.projectSetting);
    const includeBackend = projectSettingsHelperV3_1.hasFunction(ctx.projectSetting);
    const includeBot = projectSettingsHelperV3_1.hasBot(ctx.projectSetting);
    const includeAAD = projectSettingsHelperV3_1.hasAAD(ctx.projectSetting);
    const includeSimpleAuth = projectSettingsHelperV3_1.hasSimpleAuth(ctx.projectSetting);
    const skipNgrok = (_a = inputs.checkerInfo) === null || _a === void 0 ? void 0 : _a.skipNgrok;
    const includeFuncHostedBot = projectSettingsHelperV3_1.hasFunctionBot(ctx.projectSetting);
    const botCapabilities = projectSettingsHelper_1.ProjectSettingsHelper.getBotCapabilities(ctx.projectSetting);
    const telemetryProperties = {
        platform: inputs.platform,
        vscenv: vscEnv,
        frontend: includeTab ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "skip-ngrok": skipNgrok ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
    };
    telemetry_1.TelemetryUtils.init(ctx.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, telemetryProperties);
    try {
        // setup configs used by other plugins
        // TODO: dynamicly determine local ports
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            const frontendPort = 53000;
            const authPort = 55000;
            let localTabEndpoint;
            let localTabDomain;
            let localAuthEndpoint;
            let localFuncEndpoint;
            if (vscEnv === teamsfx_api_1.VsCodeEnv.codespaceBrowser || vscEnv === teamsfx_api_1.VsCodeEnv.codespaceVsCode) {
                const codespaceName = await codespace_1.getCodespaceName();
                localTabEndpoint = codespace_1.getCodespaceUrl(codespaceName, frontendPort);
                localTabDomain = new URL(localTabEndpoint).host;
                localAuthEndpoint = codespace_1.getCodespaceUrl(codespaceName, authPort);
                localFuncEndpoint = codespace_1.getCodespaceUrl(codespaceName, 7071);
            }
            else {
                localTabDomain = "localhost";
                localTabEndpoint = `https://localhost:${frontendPort}`;
                localAuthEndpoint = `http://localhost:${authPort}`;
                localFuncEndpoint = "http://localhost:7071";
            }
            if (includeAAD) {
                if (!envInfo.state[constants_2.ComponentNames.SimpleAuth]) {
                    envInfo.state[constants_2.ComponentNames.SimpleAuth] = {};
                }
                if (includeSimpleAuth) {
                    envInfo.state[constants_2.ComponentNames.SimpleAuth].endpoint = localAuthEndpoint;
                }
            }
            if (includeTab) {
                if (!envInfo.state[constants_2.ComponentNames.TeamsTab]) {
                    envInfo.state[constants_2.ComponentNames.TeamsTab] = {};
                }
                envInfo.state[constants_2.ComponentNames.TeamsTab].endpoint = localTabEndpoint;
                envInfo.state[constants_2.ComponentNames.TeamsTab].domain = localTabDomain;
            }
            if (includeBackend) {
                if (!envInfo.state[constants_2.ComponentNames.Function]) {
                    envInfo.state[constants_2.ComponentNames.Function] = {};
                }
                envInfo.state[constants_2.ComponentNames.Function].functionEndpoint = localFuncEndpoint;
            }
            if (includeBot) {
                if (!envInfo.state[constants_2.ComponentNames.TeamsBot]) {
                    envInfo.state[constants_2.ComponentNames.TeamsBot] = {};
                }
                if (skipNgrok) {
                    const localBotEndpoint = (_b = envInfo.config.bot) === null || _b === void 0 ? void 0 : _b.siteEndpoint;
                    if (localBotEndpoint === undefined) {
                        const error = error_1.LocalBotEndpointNotConfigured();
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    const botEndpointRegex = /https:\/\/.*(:\d+)?/g;
                    if (!botEndpointRegex.test(localBotEndpoint)) {
                        const error = error_1.InvalidLocalBotEndpointFormat(localBotEndpoint);
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    envInfo.state[constants_2.ComponentNames.TeamsBot].endpoint = localBotEndpoint;
                    envInfo.state[constants_2.ComponentNames.TeamsBot].domain = localBotEndpoint.slice(8);
                }
                else {
                    const ngrokHttpUrl = await ngrok_1.getNgrokHttpUrl(3978);
                    if (!ngrokHttpUrl) {
                        const error = error_1.NgrokTunnelNotConnected();
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    else {
                        envInfo.state[constants_2.ComponentNames.TeamsBot].endpoint = ngrokHttpUrl;
                        envInfo.state[constants_2.ComponentNames.TeamsBot].domain = ngrokHttpUrl.slice(8);
                    }
                }
            }
        }
        else if (inputs.platform === teamsfx_api_1.Platform.VS) {
            if (includeTab) {
                (_c = (_e = envInfo.state)[_f = constants_2.ComponentNames.TeamsTab]) !== null && _c !== void 0 ? _c : (_e[_f] = {});
                envInfo.state[constants_2.ComponentNames.TeamsTab].endpoint = "https://localhost:44302";
                envInfo.state[constants_2.ComponentNames.TeamsTab].domain = "localhost";
            }
            if (includeBot) {
                (_d = (_g = envInfo.state)[_h = constants_2.ComponentNames.TeamsBot]) !== null && _d !== void 0 ? _d : (_g[_h] = {});
                const ngrokHttpUrl = await ngrok_1.getNgrokHttpUrl(5130);
                if (!ngrokHttpUrl) {
                    const error = error_1.NgrokTunnelNotConnected();
                    telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                    return teamsfx_api_1.err(error);
                }
                else {
                    envInfo.state[constants_2.ComponentNames.TeamsBot].endpoint = ngrokHttpUrl;
                    envInfo.state[constants_2.ComponentNames.TeamsBot].domain = ngrokHttpUrl.slice(8);
                }
            }
        }
    }
    catch (error) {
        const systemError = error_1.SetupLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.setupLocalEnvironment = setupLocalEnvironment;
async function configLocalEnvironment(ctx, inputs, envInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const includeTab = projectSettingsHelperV3_1.hasAzureTab(ctx.projectSetting);
    const includeBackend = projectSettingsHelperV3_1.hasFunction(ctx.projectSetting);
    const includeBot = projectSettingsHelperV3_1.hasBot(ctx.projectSetting);
    const includeAAD = projectSettingsHelperV3_1.hasAAD(ctx.projectSetting);
    const includeSimpleAuth = projectSettingsHelperV3_1.hasSimpleAuth(ctx.projectSetting);
    const includeFuncHostedBot = projectSettingsHelperV3_1.hasFunctionBot(ctx.projectSetting);
    const botCapabilities = projectSettingsHelper_1.ProjectSettingsHelper.getBotCapabilities(ctx.projectSetting);
    let trustDevCert = (_a = inputs.checkerInfo) === null || _a === void 0 ? void 0 : _a.trustDevCert;
    const telemetryProperties = {
        platform: inputs.platform,
        frontend: includeTab ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
        "trust-development-certificate": trustDevCert + "",
    };
    telemetry_1.TelemetryUtils.init(ctx.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, telemetryProperties);
    try {
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            const localEnvProvider = new localEnvProvider_1.LocalEnvProvider(inputs.projectPath);
            const frontendEnvs = includeTab
                ? await localEnvProvider.loadFrontendLocalEnvs(includeBackend, includeAAD)
                : undefined;
            const backendEnvs = includeBackend
                ? await localEnvProvider.loadBackendLocalEnvs()
                : undefined;
            const botEnvs = includeBot ? await localEnvProvider.loadBotLocalEnvs() : undefined;
            // get config for local debug
            const clientId = (_b = envInfo.state[constants_2.ComponentNames.AadApp]) === null || _b === void 0 ? void 0 : _b.clientId;
            const clientSecret = (_c = envInfo.state[constants_2.ComponentNames.AadApp]) === null || _c === void 0 ? void 0 : _c.clientSecret;
            const applicationIdUri = (_d = envInfo.state[constants_2.ComponentNames.AadApp]) === null || _d === void 0 ? void 0 : _d.applicationIdUris;
            const teamsAppTenantId = envInfo.state[constants_2.ComponentNames.AppManifest].tenantId;
            const localTabEndpoint = (_e = envInfo.state[constants_2.ComponentNames.TeamsTab]) === null || _e === void 0 ? void 0 : _e.endpoint;
            const localFuncEndpoint = (_f = envInfo.state[constants_2.ComponentNames.Function]) === null || _f === void 0 ? void 0 : _f.functionEndpoint;
            const localAuthEndpoint = (_g = envInfo.state[constants_2.ComponentNames.SimpleAuth]) === null || _g === void 0 ? void 0 : _g.endpoint;
            const localAuthPackagePath = (_h = envInfo.state[constants_2.ComponentNames.SimpleAuth]) === null || _h === void 0 ? void 0 : _h.simpleAuthFilePath;
            if (includeTab) {
                frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.Port] = "53000";
                if (includeAAD) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.LoginUrl] = `${localTabEndpoint}/auth-start.html`;
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.ClientId] = clientId;
                }
                if (includeSimpleAuth) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.TeamsFxEndpoint] = localAuthEndpoint;
                    await localService_1.prepareLocalAuthService(localAuthPackagePath);
                }
                if (includeBackend) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.FuncEndpoint] = localFuncEndpoint;
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.FuncName] = ctx.projectSetting
                        .defaultFunctionName;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.FuncWorkerRuntime] = "node";
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ClientId] = clientId;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ClientSecret] = clientSecret;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.AuthorityHost] =
                        "https://login.microsoftonline.com";
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.TenantId] = teamsAppTenantId;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApiEndpoint] = localFuncEndpoint;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApplicationIdUri] = applicationIdUri;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.AllowedAppIds] =
                        tools_1.getAllowedAppIds().join(";");
                }
                // setup local certificate
                try {
                    if (trustDevCert === undefined) {
                        trustDevCert = true;
                    }
                    const certManager = new localCertificateManager_1.LocalCertificateManager(ctx.userInteraction, ctx.logProvider);
                    const localCert = await certManager.setupCertificate(trustDevCert);
                    if (envInfo.config.frontend &&
                        envInfo.config.frontend.sslCertFile &&
                        envInfo.config.frontend.sslKeyFile) {
                        envInfo.state[constants_2.ComponentNames.TeamsTab].sslCertFile =
                            envInfo.config.frontend.sslCertFile;
                        envInfo.state[constants_2.ComponentNames.TeamsTab].sslKeyFile = envInfo.config.frontend.sslKeyFile;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslCrtFile] =
                            envInfo.config.frontend.sslCertFile;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslKeyFile] =
                            envInfo.config.frontend.sslKeyFile;
                    }
                    else if (localCert) {
                        envInfo.state[constants_2.ComponentNames.TeamsTab].sslCertFile = localCert.certPath;
                        envInfo.state[constants_2.ComponentNames.TeamsTab].sslKeyFile = localCert.keyPath;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslCrtFile] = localCert.certPath;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslKeyFile] = localCert.keyPath;
                    }
                }
                catch (error) {
                    // do not break if cert error
                }
            }
            if (includeBot) {
                const botId = (_j = envInfo.state[constants_2.ComponentNames.BotService]) === null || _j === void 0 ? void 0 : _j.botId;
                const botPassword = (_k = envInfo.state[constants_2.ComponentNames.BotService]) === null || _k === void 0 ? void 0 : _k.botPassword;
                botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.BotId] = botId;
                botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.BotPassword] = botPassword;
                if (includeAAD) {
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ClientId] = clientId;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ClientSecret] = clientSecret;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.TenantID] = teamsAppTenantId;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.OauthAuthority] =
                        "https://login.microsoftonline.com";
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.LoginEndpoint] = `${(_l = envInfo.state[constants_2.ComponentNames.TeamsBot]) === null || _l === void 0 ? void 0 : _l.siteEndpoint}/auth-start.html`;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ApplicationIdUri] = applicationIdUri;
                }
                if (includeBackend) {
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApiEndpoint] = localFuncEndpoint;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ApiEndpoint] = localFuncEndpoint;
                }
            }
            // save .env.teamsfx.local
            await localEnvProvider.saveLocalEnvs(frontendEnvs, backendEnvs, botEnvs);
        }
    }
    catch (error) {
        const systemError = error_1.ConfigLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.configLocalEnvironment = configLocalEnvironment;
async function generateLocalDebugSettings(context, inputs) {
    var _a;
    const isSpfx = projectSettingsHelperV3_1.hasSPFxTab(context.projectSetting);
    const includeFrontend = projectSettingsHelperV3_1.hasTab(context.projectSetting);
    const includeBackend = projectSettingsHelperV3_1.hasFunction(context.projectSetting);
    const includeBot = projectSettingsHelperV3_1.hasBot(context.projectSetting);
    const includeAAD = projectSettingsHelperV3_1.hasAAD(context.projectSetting);
    const includeSimpleAuth = projectSettingsHelperV3_1.hasSimpleAuth(context.projectSetting);
    const includeFuncHostedBot = projectSettingsHelperV3_1.hasFunctionBot(context.projectSetting);
    const botCapabilities = projectSettingsHelper_1.ProjectSettingsHelper.getBotCapabilities(context.projectSetting);
    const programmingLanguage = (_a = context.projectSetting.programmingLanguage) !== null && _a !== void 0 ? _a : "";
    const isM365 = context.projectSetting.isM365;
    const telemetryProperties = {
        platform: inputs.platform,
        spfx: isSpfx ? "true" : "false",
        frontend: includeFrontend ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
        "programming-language": programmingLanguage,
    };
    telemetry_1.TelemetryUtils.init(context.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, telemetryProperties);
    try {
        // scaffold for both vscode and cli
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            if (isSpfx) {
                // Only generate launch.json and tasks.json for SPFX
                const launchConfigurations = Launch.generateSpfxConfigurations();
                const launchCompounds = Launch.generateSpfxCompounds();
                const tasks = Tasks.generateSpfxTasks();
                const tasksInputs = Tasks.generateInputs();
                //TODO: save files via context api
                await fs_extra_1.default.ensureDir(`${inputs.projectPath}/.vscode/`);
                await scaffolding_1.updateJson(`${inputs.projectPath}/.vscode/launch.json`, {
                    version: "0.2.0",
                    configurations: launchConfigurations,
                    compounds: launchCompounds,
                }, LaunchNext.mergeLaunches);
                await scaffolding_1.updateJson(`${inputs.projectPath}/.vscode/tasks.json`, {
                    version: "2.0.0",
                    tasks: tasks,
                    inputs: tasksInputs,
                }, TasksNext.mergeTasks);
            }
            else {
                const launchConfigurations = isM365
                    ? LaunchNext.generateM365Configurations(includeFrontend, includeBackend, includeBot)
                    : (await scaffolding_1.useNewTasks(inputs.projectPath))
                        ? LaunchNext.generateConfigurations(includeFrontend, includeBackend, includeBot)
                        : Launch.generateConfigurations(includeFrontend, includeBackend, includeBot);
                const launchCompounds = isM365
                    ? LaunchNext.generateM365Compounds(includeFrontend, includeBackend, includeBot)
                    : (await scaffolding_1.useNewTasks(inputs.projectPath))
                        ? LaunchNext.generateCompounds(includeFrontend, includeBackend, includeBot)
                        : Launch.generateCompounds(includeFrontend, includeBackend, includeBot);
                const tasks = isM365
                    ? TasksNext.generateM365Tasks(includeFrontend, includeBackend, includeBot, programmingLanguage)
                    : (await scaffolding_1.useNewTasks(inputs.projectPath))
                        ? TasksNext.generateTasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, programmingLanguage)
                        : Tasks.generateTasks(includeFrontend, includeBackend, includeBot, includeSimpleAuth, programmingLanguage);
                //TODO: save files via context api
                await fs_extra_1.default.ensureDir(`${inputs.projectPath}/.vscode/`);
                await scaffolding_1.updateJson(`${inputs.projectPath}/.vscode/launch.json`, {
                    version: "0.2.0",
                    configurations: launchConfigurations,
                    compounds: launchCompounds,
                }, LaunchNext.mergeLaunches);
                await scaffolding_1.updateJson(`${inputs.projectPath}/.vscode/tasks.json`, {
                    version: "2.0.0",
                    tasks: tasks,
                }, TasksNext.mergeTasks);
            }
            await scaffolding_1.updateJson(`${inputs.projectPath}/.vscode/settings.json`, Settings.generateSettings(includeBackend || includeFuncHostedBot, isSpfx), Settings.mergeSettings);
        }
    }
    catch (error) {
        const systemError = error_1.ScaffoldLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.generateLocalDebugSettings = generateLocalDebugSettings;
//# sourceMappingURL=debug.js.map