// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHostedByAzure = exports.generateResourceBaseName = exports.normalizeName = exports.createContextV3 = exports.newProjectSettingsV3 = exports.fileEffectPlanString = exports.appendFileEffect = exports.createFileEffect = exports.createFilesEffects = exports.serviceEffectPlanString = exports.fileEffectPlanStrings = exports.persistBicepPlans = exports.persistBicep = exports.persistParams = exports.persistParamsBicepPlans = exports.persistConfigBicepPlans = exports.persistConfigBicep = exports.persistProvisionBicepPlans = exports.persistProvisionBicep = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os_1 = tslib_1.__importDefault(require("os"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const crypto_1 = require("../core/crypto");
const environment_1 = require("../core/environment");
const globalVars_1 = require("../core/globalVars");
const constants_2 = require("../plugins/solution/fx-solution/constants");
const uuid = tslib_1.__importStar(require("uuid"));
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const manifestProvider_1 = require("./resource/appManifest/manifestProvider");
const utils_1 = require("../common/utils");
async function persistProvisionBicep(projectPath, provisionBicep) {
    const templateFolder = path.join(projectPath, "templates", "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "provision", `${module}.bicep`);
                await fs_extra_1.default.appendFile(filePath, value.replace(/\r?\n/g, os_1.default.EOL).trim());
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        await fs_extra_1.default.appendFile(filePath, os_1.default.EOL + os_1.default.EOL + provisionBicep.Orchestration.trim().replace(/\r?\n/g, os_1.default.EOL));
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistProvisionBicep = persistProvisionBicep;
async function persistProvisionBicepPlans(projectPath, provisionBicep) {
    const plans = [];
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "provision", `${module}.bicep`);
                const effect = appendFileEffect(filePath, `provision module bicep for ${module}`);
                const plan = fileEffectPlanString(effect);
                if (plan) {
                    plans.push(plan);
                }
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        const effect = appendFileEffect(filePath, "provision orchestration bicep");
        const plan = fileEffectPlanString(effect);
        if (plan) {
            plans.push(plan);
        }
    }
    return plans;
}
exports.persistProvisionBicepPlans = persistProvisionBicepPlans;
async function persistConfigBicep(projectPath, configBicep) {
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (configBicep.Modules) {
        for (const module of Object.keys(configBicep.Modules)) {
            const value = configBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "teamsFx", `${module}.bicep`);
                fs_extra_1.default.writeFileSync(filePath, value.replace(/\r?\n/g, os_1.default.EOL).trim(), { encoding: "utf-8" });
            }
        }
    }
    if (configBicep.Orchestration) {
        const filePath = path.join(templateFolder, "config.bicep");
        fs_extra_1.default.appendFileSync(filePath, os_1.default.EOL + os_1.default.EOL + configBicep.Orchestration.trim().replace(/\r?\n/g, os_1.default.EOL));
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistConfigBicep = persistConfigBicep;
async function persistConfigBicepPlans(projectPath, provisionBicep) {
    const plans = [];
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "teamsFx", `${module}.bicep`);
                const effect = createFileEffect(filePath, "replace", `configuration module bicep for ${module}`);
                const plan = fileEffectPlanString(effect);
                if (plan) {
                    plans.push(plan);
                }
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        const effect = appendFileEffect(filePath, "configuration orchestration bicep");
        const plan = fileEffectPlanString(effect);
        if (plan) {
            plans.push(plan);
        }
    }
    return plans;
}
exports.persistConfigBicepPlans = persistConfigBicepPlans;
function persistParamsBicepPlans(projectPath, params) {
    const plans = [];
    if (Object.keys(params).length === 0)
        return [];
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    fs_extra_1.default.ensureDirSync(parameterEnvFolderPath);
    const configFiles = fs_extra_1.default.readdirSync(parameterEnvFolderPath);
    const remoteEnvNames = configFiles
        .map((file) => {
        const match = /^config\.(?<envName>[\w\d-_]+)\.json$/i.exec(file);
        if (match != null && match.groups != null) {
            const envName = match.groups.envName;
            if (envName !== "local")
                return envName;
        }
        return null;
    })
        .filter((env) => env !== null);
    for (const env of remoteEnvNames) {
        const parameterFileName = `azure.parameters.${env}.json`;
        const parameterEnvFilePath = path.join(parameterEnvFolderPath, parameterFileName);
        const effect = createFileEffect(parameterEnvFilePath, "replace");
        const plan = fileEffectPlanString(effect);
        if (plan)
            plans.push(plan);
    }
    return plans;
}
exports.persistParamsBicepPlans = persistParamsBicepPlans;
async function persistParams(projectPath, appName, params) {
    const envListResult = await environment_1.environmentManager.listRemoteEnvConfigs(projectPath);
    if (envListResult.isErr()) {
        return teamsfx_api_1.err(envListResult.error);
    }
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    await fs_extra_1.default.ensureDir(parameterEnvFolderPath);
    for (const env of envListResult.value) {
        const parameterFileName = `azure.parameters.${env}.json`;
        const parameterEnvFilePath = path.join(parameterEnvFolderPath, parameterFileName);
        let parameterFileContent = undefined;
        if (await fs_extra_1.default.pathExists(parameterEnvFilePath)) {
            if (params) {
                const json = await fs_extra_1.default.readJson(parameterEnvFilePath);
                const existingParams = json.parameters.provisionParameters.value;
                const dupParamKeys = Object.keys(params).filter((val) => Object.keys(existingParams).includes(val));
                if (dupParamKeys && dupParamKeys.length != 0) {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                        name: constants_2.SolutionError.FailedToUpdateArmParameters,
                        source: "bicep",
                        helpLink: constants_1.HelpLinks.ArmHelpLink,
                        message: localizeUtils_1.getDefaultString("core.generateArmTemplates.DuplicateParameter", parameterEnvFilePath, dupParamKeys),
                        displayMessage: localizeUtils_1.getLocalizedString("core.generateArmTemplates.DuplicateParameter", parameterEnvFilePath, dupParamKeys),
                    }));
                }
                Object.assign(existingParams, params);
                if (!existingParams.resourceBaseName) {
                    params.resourceBaseName = generateResourceBaseName(appName, "");
                }
                json.parameters.provisionParameters.value = existingParams;
                parameterFileContent = JSON.stringify(json, undefined, 2);
            }
        }
        else {
            params = params || {};
            if (!params.resourceBaseName) {
                params.resourceBaseName = generateResourceBaseName(appName, "");
            }
            const parameterObject = {
                $schema: "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
                contentVersion: "1.0.0.0",
                parameters: { provisionParameters: { value: params } },
            };
            parameterFileContent = JSON.stringify(parameterObject, undefined, 2);
        }
        if (parameterFileContent) {
            parameterFileContent = parameterFileContent.replace(/\r?\n/g, os_1.default.EOL);
            await fs_extra_1.default.writeFile(parameterEnvFilePath, parameterFileContent);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistParams = persistParams;
async function persistBicep(projectPath, appName, bicep) {
    if (bicep.Provision) {
        const res = await persistProvisionBicep(projectPath, bicep.Provision);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
    }
    if (bicep.Configuration) {
        const res = await persistConfigBicep(projectPath, bicep.Configuration);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
    }
    // if (bicep.Parameters) {
    const res = await persistParams(projectPath, appName, bicep.Parameters);
    if (res.isErr())
        return teamsfx_api_1.err(res.error);
    // }
    return teamsfx_api_1.ok(undefined);
}
exports.persistBicep = persistBicep;
async function persistBicepPlans(projectPath, bicep) {
    let plans = [];
    if (bicep.Provision) {
        const res = await persistProvisionBicepPlans(projectPath, bicep.Provision);
        plans = plans.concat(res);
    }
    if (bicep.Configuration) {
        const res = await persistConfigBicepPlans(projectPath, bicep.Configuration);
        plans = plans.concat(res);
    }
    if (bicep.Parameters) {
        const res = persistParamsBicepPlans(projectPath, bicep.Parameters);
        plans = plans.concat(res);
    }
    return plans.filter(Boolean);
}
exports.persistBicepPlans = persistBicepPlans;
function fileEffectPlanStrings(fileEffect) {
    const plans = [];
    if (typeof fileEffect.filePath === "string") {
        plans.push(fileEffectPlanString(fileEffect));
    }
    else {
        for (const file of fileEffect.filePath) {
            plans.push(fileEffectPlanString(Object.assign(Object.assign({}, fileEffect), { filePath: file, remarks: undefined })));
        }
    }
    return plans.filter((p) => p !== undefined);
}
exports.fileEffectPlanStrings = fileEffectPlanStrings;
function serviceEffectPlanString(serviceEffect) {
    return `call cloud service: ${serviceEffect.name} (${serviceEffect.remarks})`;
}
exports.serviceEffectPlanString = serviceEffectPlanString;
function createFilesEffects(files, operateIfExists = "replace", remarks) {
    const effects = [];
    for (const file of files) {
        if (fs_extra_1.default.pathExistsSync(file)) {
            if (operateIfExists === "replace") {
                effects.push({
                    type: "file",
                    filePath: file,
                    operate: "replace",
                    remarks: remarks,
                });
            }
            else {
                effects.push({
                    type: "file",
                    filePath: file,
                    operate: "skipCreate",
                    remarks: remarks,
                });
            }
        }
        else {
            effects.push({
                type: "file",
                filePath: file,
                operate: "create",
                remarks: remarks,
            });
        }
    }
    return effects;
}
exports.createFilesEffects = createFilesEffects;
function createFileEffect(file, operateIfExists = "replace", remarks) {
    if (fs_extra_1.default.pathExistsSync(file)) {
        if (operateIfExists === "replace") {
            return {
                type: "file",
                filePath: file,
                operate: "replace",
                remarks: remarks,
            };
        }
        else if (operateIfExists === "skip") {
            return {
                type: "file",
                filePath: file,
                operate: "skipCreate",
                remarks: remarks,
            };
        }
        else {
            return {
                type: "file",
                filePath: file,
                operate: "append",
                remarks: remarks,
            };
        }
    }
    else {
        return {
            type: "file",
            filePath: file,
            operate: "create",
            remarks: remarks,
        };
    }
}
exports.createFileEffect = createFileEffect;
function appendFileEffect(file, remarks) {
    if (fs_extra_1.default.pathExistsSync(file)) {
        return {
            type: "file",
            filePath: file,
            operate: "append",
            remarks: remarks,
        };
    }
    else {
        return {
            type: "file",
            filePath: file,
            operate: "create",
            remarks: remarks,
        };
    }
}
exports.appendFileEffect = appendFileEffect;
function fileEffectPlanString(effect) {
    if (effect.operate.startsWith("skip"))
        return undefined;
    return effect.remarks
        ? `${effect.operate} file: '${effect.filePath}' (${effect.remarks})`
        : `${effect.operate} file: '${effect.filePath}'`;
}
exports.fileEffectPlanString = fileEffectPlanString;
function newProjectSettingsV3() {
    const projectSettings = {
        appName: "test",
        projectId: uuid.v4(),
        version: projectSettingsHelper_1.getProjectSettingsVersion(),
        components: [],
    };
    return projectSettings;
}
exports.newProjectSettingsV3 = newProjectSettingsV3;
function createContextV3(projectSettings) {
    if (!projectSettings)
        projectSettings = newProjectSettingsV3();
    const context = {
        userInteraction: globalVars_1.TOOLS.ui,
        logProvider: globalVars_1.TOOLS.logProvider,
        telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
        cryptoProvider: new crypto_1.LocalCrypto(projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.projectId),
        permissionRequestProvider: globalVars_1.TOOLS.permissionRequest,
        projectSetting: projectSettings,
        manifestProvider: new manifestProvider_1.DefaultManifestProvider(),
        tokenProvider: globalVars_1.TOOLS.tokenProvider,
    };
    return context;
}
exports.createContextV3 = createContextV3;
function normalizeName(appName) {
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return normalizedAppName;
}
exports.normalizeName = normalizeName;
function generateResourceBaseName(appName, envName) {
    const maxAppNameLength = 10;
    const maxEnvNameLength = 4;
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    const normalizedEnvName = envName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return (normalizedAppName.substr(0, maxAppNameLength) +
        normalizedEnvName.substr(0, maxEnvNameLength) +
        uuid.v4().substr(0, 6));
}
exports.generateResourceBaseName = generateResourceBaseName;
// TODO:implement after V3 project setting update
function isHostedByAzure(context) {
    return true;
}
exports.isHostedByAzure = isHostedByAzure;
//# sourceMappingURL=utils.js.map