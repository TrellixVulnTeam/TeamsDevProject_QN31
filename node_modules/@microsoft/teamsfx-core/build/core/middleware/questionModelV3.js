"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuestionModelMW_V3 = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../../common/constants");
const localizeUtils_1 = require("../../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../../common/projectSettingsHelperV3");
const tools_1 = require("../../common/tools");
const constants_2 = require("../../plugins/resource/appstudio/constants");
const question_1 = require("../../plugins/resource/bot/question");
const question_2 = require("../../plugins/solution/fx-solution/question");
const utils_1 = require("../../plugins/solution/fx-solution/v2/utils");
const error_1 = require("../error");
const globalVars_1 = require("../globalVars");
const question_3 = require("../question");
const envInfoLoader_1 = require("./envInfoLoader");
/**
 * This middleware will help to collect input from question flow
 */
const QuestionModelMW_V3 = async (ctx, next) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const method = ctx.method;
    let getQuestionRes = teamsfx_api_1.ok(undefined);
    if (method === "createProjectV3") {
        getQuestionRes = await createProjectQuestionV3(inputs);
    }
    else if (method === "provisionResourcesV3") {
        getQuestionRes = await envInfoLoader_1.getQuestionsForTargetEnv(inputs);
    }
    else if (method === "deployArtifactsV3") {
        getQuestionRes = await getQuestionsForDeploy(ctx.contextV2, ctx.envInfoV3, inputs);
    }
    else if (method === "addFeature") {
        getQuestionRes = await getQuestionsForAddFeature(ctx.contextV2, inputs);
    }
    if (getQuestionRes.isErr()) {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.error(`[core] failed to get questions for ${method}: ${getQuestionRes.error.message}`);
        ctx.result = teamsfx_api_1.err(getQuestionRes.error);
        return;
    }
    globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.debug(`[core] success to get questions for ${method}`);
    const node = getQuestionRes.value;
    if (node) {
        const res = await teamsfx_api_1.traverse(node, inputs, globalVars_1.TOOLS.ui, globalVars_1.TOOLS.telemetryReporter);
        if (res.isErr()) {
            globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.debug(`[core] failed to run question model for ${method}`);
            ctx.result = teamsfx_api_1.err(res.error);
            return;
        }
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.info(`[core] success to run question model for ${method}, answers:${JSON.stringify(inputs)}`);
    }
    await next();
};
exports.QuestionModelMW_V3 = QuestionModelMW_V3;
async function createProjectQuestionV3(inputs) {
    const node = new teamsfx_api_1.QTreeNode(question_3.getCreateNewOrFromSampleQuestion(inputs.platform));
    // create new
    const root = new teamsfx_api_1.QTreeNode({ type: "group" });
    node.addChild(root);
    root.condition = { equals: question_3.ScratchOptionYes.id };
    // capabilities
    const capQuestion = question_3.createCapabilityQuestionPreview();
    const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    root.addChild(capNode);
    const triggerQuestion = question_1.createHostTypeTriggerQuestion(inputs.platform);
    const triggerNode = new teamsfx_api_1.QTreeNode(triggerQuestion);
    triggerNode.condition = { equals: question_2.NotificationOptionItem.id };
    capNode.addChild(triggerNode);
    // Language
    const programmingLanguage = new teamsfx_api_1.QTreeNode(question_3.ProgrammingLanguageQuestion);
    capNode.addChild(programmingLanguage);
    root.addChild(new teamsfx_api_1.QTreeNode(question_3.QuestionRootFolder));
    root.addChild(new teamsfx_api_1.QTreeNode(question_3.createAppNameQuestion()));
    // create from sample
    const sampleNode = new teamsfx_api_1.QTreeNode(question_3.SampleSelect);
    node.addChild(sampleNode);
    sampleNode.condition = { equals: question_3.ScratchOptionNo.id };
    sampleNode.addChild(new teamsfx_api_1.QTreeNode(question_3.QuestionRootFolder));
    return teamsfx_api_1.ok(node.trim());
}
async function getQuestionsForDeploy(ctx, envInfo, inputs) {
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    const projectSetting = ctx.projectSetting;
    if (isDynamicQuestion) {
        const hasAzureResource = projectSettingsHelperV3_1.hasAzureResourceV3(projectSetting);
        const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
        if (hasAzureResource && !provisioned) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                source: "fx",
                name: "CannotDeployBeforeProvision",
                message: localizeUtils_1.getDefaultString("core.deploy.FailedToDeployBeforeProvision"),
                displayMessage: localizeUtils_1.getLocalizedString("core.deploy.FailedToDeployBeforeProvision"),
                helpLink: constants_1.HelpLinks.WhyNeedProvision,
            }));
        }
        const selectComponentsQuestion = {
            name: "deploy-plugin",
            title: "Select component(s) to deploy",
            type: "multiSelect",
            skipSingleOption: false,
            staticOptions: [],
            default: [],
        };
        selectComponentsQuestion.staticOptions = projectSetting.components
            .filter((component) => component.build && component.hosting)
            .map((component) => {
            const item = {
                id: component.name,
                label: component.name,
                cliName: component.name,
            };
            return item;
        });
        if (selectComponentsQuestion.staticOptions.length === 0) {
            return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.deploy));
        }
        return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(selectComponentsQuestion));
    }
    return teamsfx_api_1.ok(undefined);
}
async function getQuestionsForAddFeature(ctx, inputs) {
    const question = {
        name: "feature",
        title: localizeUtils_1.getLocalizedString("core.addFeatureQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
    };
    const options = [];
    // check capability options
    const appDir = await tools_1.getAppDirectory(inputs.projectPath);
    const manifestPath = path.resolve(appDir, constants_2.MANIFEST_TEMPLATE_CONSOLIDATE);
    const manifest = (await fs_extra_1.default.readJson(manifestPath));
    const canAddTab = manifest.staticTabs.length < constants_2.STATIC_TABS_MAX_ITEMS;
    const canAddBot = manifest.bots.length < 1;
    const canAddME = manifest.composeExtensions.length < 1;
    const projectSettingsV3 = ctx.projectSetting;
    if (canAddBot) {
        options.push(question_2.NotificationOptionItem);
        options.push(question_2.CommandAndResponseOptionItem);
    }
    if (canAddTab) {
        if (projectSettingsHelperV3_1.hasTab(projectSettingsV3)) {
            options.push(question_2.TabNewUIOptionItem, question_2.TabNonSsoItem);
        }
        else {
            //if aad is added, display name is SsoTab, otherwise the display name is NonSsoTab
            if (projectSettingsHelperV3_1.hasAAD(projectSettingsV3)) {
                options.push(question_2.TabNewUIOptionItem);
            }
            else {
                options.push(question_2.TabNonSsoItem);
            }
        }
    }
    if (canAddBot) {
        options.push(question_2.BotNewUIOptionItem);
    }
    if (canAddME) {
        options.push(question_2.MessageExtensionNewUIItem);
    }
    // check cloud resource options
    if (!projectSettingsHelperV3_1.hasAPIM(projectSettingsV3)) {
        options.push(question_2.AzureResourceApimNewUI);
    }
    options.push(question_2.AzureResourceSQLNewUI);
    if (!projectSettingsHelperV3_1.hasKeyVault(projectSettingsV3)) {
        options.push(question_2.AzureResourceKeyVaultNewUI);
    }
    if (!projectSettingsHelperV3_1.hasAAD(projectSettingsV3)) {
        options.push(question_2.SingleSignOnOptionItem);
    }
    if (projectSettingsHelperV3_1.hasBot(projectSettingsV3) || projectSettingsHelperV3_1.hasFunction(projectSettingsV3)) {
        options.push(question_2.ApiConnectionOptionItem);
    }
    const isCicdAddable = await tools_1.canAddCICDWorkflows(inputs, ctx);
    if (isCicdAddable) {
        options.push(question_2.CicdOptionItem);
    }
    question.staticOptions = options;
    const addFeatureNode = new teamsfx_api_1.QTreeNode(question);
    if (!ctx.projectSetting.programmingLanguage) {
        // Language
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_3.ProgrammingLanguageQuestion);
        programmingLanguage.condition = {
            enum: [
                question_2.NotificationOptionItem.id,
                question_2.CommandAndResponseOptionItem.id,
                question_2.TabNewUIOptionItem.id,
                question_2.TabNonSsoItem.id,
                question_2.BotNewUIOptionItem.id,
                question_2.MessageExtensionItem.id,
                question_2.SingleSignOnOptionItem.id, // adding sso means adding sample codes
            ],
        };
        addFeatureNode.addChild(programmingLanguage);
    }
    return teamsfx_api_1.ok(addFeatureNode);
}
//# sourceMappingURL=questionModelV3.js.map